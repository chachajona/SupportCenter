---
description: This document outlines the coding standards for our Laravel 12.x and React project.
globs:
alwaysApply: true
---
# Coding Standards

This document outlines the coding standards for our Laravel 12.x and React project.

## PHP (Laravel)

 - Follow [PSR-12](https://www.php-fig.org/psr/psr-12) coding standards
- Use type declarations for method parameters and return types
- Document classes and methods with PHPDoc blocks
- Use dependency injection wherever possible
- Keep controllers thin, move business logic to services
- Follow Laravel's naming conventions:
  - Controllers: singular, PascalCase, suffix with `Controller` (e.g., `UserController`)
  - Models: singular, PascalCase (e.g., `User`)
  - Migrations: snake_case, prefixed with timestamp (e.g., `2023_01_01_000000_create_users_table`)
  - Database tables: plural, snake_case (e.g., `users`)
  - Routes: kebab-case for web routes, snake_case for API endpoints

## JavaScript/TypeScript (React)

- Use ESLint with the configuration in [eslint.config.js](mdc:eslint.config.js)
- Follow Prettier formatting rules defined in [.prettierrc](mdc:.prettierrc)
- Use TypeScript interfaces for prop types and state
- Define types in dedicated files within [resources/js/types/](mdc:resources/js/types)
- Component naming conventions:
  - All React-related filenames (components, custom hooks, context providers) should use kebab-case (e.g., `app-header.tsx`, `use-auth.ts`, `auth-context.tsx`).
  - Component function names should use PascalCase in the code (e.g., `export function AppHeader()`).
  - Custom hook function names should be prefixed with `use` and use camelCase (e.g., `export function useAuth()`).
  - Context provider component names should use PascalCase and be suffixed with `Provider` (e.g., `export function AuthProvider()`).
  - Context interfaces should be suffixed with `Context` (e.g., `AuthContext`).
  - Use `.tsx` extension for TypeScript React components and `.ts` for custom hooks and plain TypeScript files.

- **TypeScript Interface Naming Conventions**: Interfaces should use PascalCase (e.g., `UserProfile`). Teams may optionally choose to prefix interfaces with "I" (e.g., `IUserProfile`) or suffix with "Interface" (e.g., `UserProfileInterface`) for clarity and consistency. The chosen convention should be applied consistently throughout the codebase.

### Directory Structure

- **Regular Components**: Place general-purpose UI components in `resources/js/components/`. For more complex features or "pages", create subdirectories within `resources/js/features/` or `resources/js/pages/` respectively.
  - Example: `resources/js/components/buttons/primary-button.tsx`
  - Example: `resources/js/features/authentication/components/login-form.tsx`
- **Custom Hooks**: Store custom hooks in `resources/js/hooks/`.
  - Example: `resources/js/hooks/use-auth.ts`
- **Context Providers**: Place context providers and their related types in `resources/js/contexts/`.
  - Example: `resources/js/contexts/auth-context.tsx` (contains `AuthProvider` and `AuthContext`)

## CSS/Styling

- Use Tailwind CSS utility classes for styling
- Follow the configuration in [tailwind.config.js](mdc:tailwind.config.js)
- For custom CSS, use the BEM (Block Element Modifier) methodology
- Organize styles by component when using component-specific CSS

## Testing

- Write tests for all critical functionality.
- **Mandatory Testing**: Tests are mandatory for all new features and bug fixes. Ensure that every pull request includes corresponding tests.
- **Code Coverage**: Aim for a minimum of 80% code coverage for all new code. Use coverage reports to identify untested areas.
- Follow the AAA (Arrange, Act, Assert) pattern for structuring tests.
- Use meaningful and descriptive test names that clearly indicate what is being tested.
- **Recommended Tools**:
  - Frontend (React/TypeScript): Use [Jest](https://jestjs.io) along with [React Testing Library](https:/testing-library.com/docs/react-testing-library/intro) for component testing.
  - Backend (Laravel/PHP): Use [PHPUnit](mdc:https:/phpunit.de) for unit and integration tests.
- **Mocking Strategies**:
  - For frontend tests, use Jest's built-in mocking capabilities (`jest.fn()`, `jest.spyOn()`, `jest.mock()`) to mock dependencies, API calls, and external modules.
  - For backend tests, utilize Laravel's mocking features, such as `Mockery` or PHPUnit's test doubles, to isolate units of code.
- Backend tests should be in the `tests/` directory, following Laravel's standard structure (e.g., `tests/Feature`, `tests/Unit`).
- Frontend tests should be co-located with components using a `.test.tsx` suffix (e.g., `primary-button.test.tsx`).

## Git Workflow

- Write clear, concise commit messages
- Use feature branches for new development
- Submit pull requests for code review
- Keep pull requests focused on a single feature or bug fix
- Reference issue numbers in commit messages and pull requests

## Ownership and Governance

The coding standards are owned and maintained by the **Lead Development Team**.

### Proposing Changes

To propose changes or updates to these standards:
1. Create an issue in the project's issue tracker detailing the proposed change and the reasoning behind it.
2. If the change is substantial, create a discussion document or a pull request with the suggested modifications to this file.
3. The Lead Development Team will review the proposal, discuss it with relevant stakeholders if necessary, and make a decision.
4. Approved changes will be merged into this document.

For any questions or clarifications, please contact the Lead Development Team via [#dev-standards-discussion](mdc:slack:/channel/dev-standards-discussion) channel or by reaching out to `lead.dev@example.com`.

### Automated Enforcement of Coding Standards

To ensure consistent code quality and adherence to these standards, automated enforcement mechanisms are integrated into the CI/CD pipeline:

- **ESLint**: Runs on all JavaScript/TypeScript files to enforce code style, best practices, and catch potential errors.
- **Prettier**: Automatically checks and formats code style for supported file types, ensuring a consistent codebase appearance.
- **PHPStan**: Analyzes PHP code for type safety and potential issues, enforcing strict standards for Laravel code.

These tools are executed automatically as part of the pull request (PR) validation process. Any code that does not comply with the defined standards will cause the PR checks to fail, requiring issues to be addressed before merging. This automated process helps maintain high code quality and reduces manual review effort by catching common issues early in the development workflow.
