---
description:
globs:
alwaysApply: false
---
# MFA Implementation Plan (Weeks 3-4 Roadmap)

This document outlines the plan for implementing Multi-Factor Authentication (MFA) into the project.

## Weeks 3-4: Multi-Factor Authentication To-Do List

### 1. Implement 2FA with Authenticator Apps (TOTP) using Laravel Fortify (NEW Priority)

#### Backend (Laravel)

1.  **Ensure Laravel Fortify is Installed and Configured:**
    *   If not already done for basic authentication, run `composer require laravel/fortify`.
    *   Publish Fortify's resources: `php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"`.
2.  **Enable Fortify 2FA Feature:**
    *   In `[config/fortify.php](mdc:config/fortify.php)`, enable the `twoFactorAuthentication` feature. It's recommended to use Fortify's built-in confirmation flow initially.
        ```php
        'features' => [
            Features::registration(),
            Features::resetPasswords(),
            Features::emailVerification(),
            Features::twoFactorAuthentication([
                'confirm' => true, // Use Fortify's built-in confirmation views/logic
                'recovery' => true, // Enable recovery codes
            ]),
        ],
        ```
3.  **Update User Model:**
    *   Ensure your `[app/Models/User.php](mdc:app/Models/User.php)` model uses the `Laravel\Fortify\TwoFactorAuthenticatable` trait:
        ```php
        use Laravel\Fortify\TwoFactorAuthenticatable;
        use Illuminate\Foundation\Auth\User as Authenticatable;
        use Laravel\Sanctum\HasApiTokens; // Assuming HasApiTokens is used

        class User extends Authenticatable
        {
            use TwoFactorAuthenticatable, HasApiTokens; // Add other necessary traits
            // ...
        }
        ```
4.  **Database Migrations:**
    *   Fortify's `TwoFactorAuthenticatable` trait expects certain columns in your `users` table (e.g., `two_factor_secret`, `two_factor_recovery_codes`, `two_factor_confirmed_at`). Fortify's migrations should handle this. If you added these manually before, ensure they are compatible.
    *   Run `php artisan migrate` if you haven't already after adding Fortify or if new migrations are pending.
5.  **Fortify Handles Core Logic:**
    *   QR Code Generation: Fortify provides actions that generate the QR code SVG and the secret key.
    *   Secret Storage: Encrypted shared secret is stored in the `users` table.
    *   TOTP Verification: Fortify handles the validation of codes entered by the user.
6.  **Routes:**
    *   Fortify automatically registers routes for enabling, confirming, disabling 2FA, showing recovery codes, and handling the 2FA challenge during login. These are typically under `/user/two-factor-authentication`, `/user/confirmed-two-factor-authentication`, etc.
    *   You will interact with these via your frontend.

#### Frontend (React)

1.  **User Profile/Settings Section for 2FA Management:**
    *   **Enable 2FA Component:**
        *   When a user chooses to enable 2FA:
            *   Make a POST request to Fortify's endpoint to enable 2FA (e.g., `/user/two-factor-authentication`).
            *   On success, the backend (Fortify) will typically provide the SVG QR code and the secret key (for manual entry).
            *   Display the QR code for the user to scan with their authenticator app (Google Authenticator, Authy, etc.).
            *   Provide an input field for the user to enter the 6-digit code from their authenticator app.
            *   Make a POST request to Fortify's confirmation endpoint (e.g., `/user/confirmed-two-factor-authentication`) with the code.
            *   On successful confirmation, 2FA is active. Display recovery codes immediately (see section 2).
    *   **Disable 2FA Component:**
        *   Provide a button to disable 2FA.
        *   Make a DELETE request to Fortify's endpoint (e.g., `/user/two-factor-authentication`).
    *   **View Recovery Codes Component:** (Covered in next section)

2.  **Login Flow Integration:**
    *   After a user successfully authenticates with their password, if 2FA is enabled for their account, Fortify's login response (e.g., from `/login`) will typically include a `two_factor: true` flag (or similar, check Fortify's JSON response structure).
    *   The frontend should then redirect the user to a dedicated 2FA challenge page/modal.
    *   This page will have an input field for the TOTP code.
    *   Submit the code to Fortify's 2FA challenge endpoint (e.g., `/two-factor-challenge`).
    *   Also, provide an option to use a recovery code on this page.

### 2. Set Up Backup Code System as MFA Fallback (Leveraging Fortify)

This is closely tied to the Fortify 2FA setup when `recovery => true` is enabled.

#### Backend (Laravel)

*   **Fortify Manages Recovery Codes:**
    *   When 2FA is enabled and confirmed, Fortify automatically generates a set of recovery codes.
    *   These are stored (hashed) in the `two_factor_recovery_codes` column of the `users` table.
    *   Fortify provides an endpoint (e.g., `GET /user/two-factor-recovery-codes`) to retrieve the plain-text recovery codes for the user to save. This endpoint should only be accessible when 2FA is enabled.
    *   Fortify's 2FA challenge mechanism also handles the validation of recovery codes if one is entered instead of a TOTP code.

#### Frontend (React)

1.  **Display and Manage Backup Codes:**
    *   Create/adapt the `[BackupCodes.js](mdc:resources/js/components/BackupCodes.js)` (or `.tsx`) component:
        *   This component should be shown to the user immediately after they successfully confirm and enable 2FA.
        *   It should fetch the recovery codes from Fortify's endpoint (e.g., `GET /user/two-factor-recovery-codes`).
        *   Display the codes clearly with instructions to store them securely.
        *   Offer options to copy to clipboard or print.
        *   Optionally, allow users to regenerate recovery codes (if Fortify supports this action easily or if you implement a custom action that calls Fortify's underlying logic).
        ```javascript
        // Simplified structure - adapt from original plan's BackupCodes.js
        import axios from 'axios';
        import { useState, useEffect } from 'react';

        const BackupCodes = ({ onFetched }) => { // onFetched can be a callback after codes are shown
            const [codes, setCodes] = useState([]);
            const [error, setError] = useState('');

            useEffect(() => {
                const fetchCodes = async () => {
                    try {
                        const { data } = await axios.get('/user/two-factor-recovery-codes'); // Fortify's endpoint
                        if (data.recoveryCodes) { // Adjust based on actual response structure
                            setCodes(data.recoveryCodes);
                        } else if (Array.isArray(data)) { // Fortify might return array directly
                             setCodes(data);
                        }
                         else {
                            setError('Could not retrieve backup codes. Ensure 2FA is fully enabled.');
                        }
                    } catch (err) {
                        setError('Failed to fetch backup codes: ' + (err.response?.data?.message || err.message));
                    }
                };
                fetchCodes();
            }, []);

            // ... (render logic similar to original plan, ensure it handles the exact structure Fortify returns)
            return (
                <div>
                    <h2>Your Backup Codes</h2>
                    <p><strong>Store these codes in a safe place.</strong> Each code can only be used once.</p>
                    {/* ... list codes ... */}
                </div>
            );
        };
        export default BackupCodes;
        ```

2.  **Implement Backup Code Login in 2FA Challenge:**
    *   On the 2FA challenge page/modal, provide an input field or a link like "Use a recovery code".
    *   If the user enters a recovery code, submit it to Fortify's 2FA challenge endpoint (e.g., `/two-factor-challenge` with a parameter like `recovery_code` instead of `code`). Fortify handles this distinction.

### 3. Implement WebAuthn for Secure MFA (Subsequent Step)

This section can be implemented after TOTP-based 2FA is stable. It offers an alternative or additional MFA method.

#### Backend (Laravel)

1.  **Install `laragear/webauthn` Package:** (As per original plan)
    *   `composer require laragear/webauthn`
    *   Publish config, run migrations.
    *   Customize `[config/webauthn.php](mdc:config/webauthn.php)`.

2.  **Set Up WebAuthn Routes:** (As per original plan)
    *   Create `WebauthnController` (`[app/Http/Controllers/WebauthnController.php](mdc:app/Http/Controllers/WebauthnController.php)`).
    *   Define routes in `[routes/api.php](mdc:routes/api.php)` for register-options, register, authenticate-options, authenticate.

3.  **Integrate WebAuthn with Fortify's 2FA (or as a separate MFA option):**
    *   **Option A (Modify Fortify's 2FA Challenge):**
        *   Your `TwoFactorChallengeController` concept is relevant here. You might override Fortify's default 2FA challenge view/response to offer WebAuthn as an option *alongside* TOTP.
        *   The `challenge` method could detect if a user has WebAuthn credentials registered and offer that flow.
        *   The `verify` method would handle both TOTP (delegating to Fortify or using its provider) and WebAuthn validation.
    *   **Option B (Separate WebAuthn Management):**
        *   Users could register WebAuthn keys independently of TOTP. The login flow would then need to decide which factor to prompt for, or let the user choose.
    *   The user model (`[app/Models/User.php](mdc:app/Models/User.php)`) would still use `Laravel\Fortify\TwoFactorAuthenticatable` for the Fortify part, and `laragear/webauthn` traits/methods for WebAuthn.

#### Frontend (React)

1.  **Ensure Secure Context:** (As per original plan)
2.  **Implement WebAuthn Registration Component:** (As per original plan - `[WebAuthnRegister.js](mdc:resources/js/components/WebAuthnRegister.js)`)
    *   This would be part of user settings, allowing them to add a security key.
3.  **Implement WebAuthn Authentication Logic:** (As per original plan - `[WebAuthnLogin.js](mdc:resources/js/components/WebAuthnLogin.js)`)
    *   This logic would be invoked during the 2FA challenge if WebAuthn is chosen/available.
4.  **Integrate with Login/2FA Flow:**
    *   Modify the 2FA challenge page/modal to offer "Authenticate with Security Key / WebAuthn" if the user has a key registered.

### 4. Add Device Fingerprinting for Enhanced Security
(This section remains largely the same as the original plan - renumbered)

#### Frontend (React)
1.  **Install FingerprintJS:** `npm install @fingerprintjs/fingerprintjs`.
2.  **Collect Device Fingerprint:** Integrate into login/registration.

#### Backend (Laravel)
1.  **Store Device Fingerprint:** Add `device_fingerprint` column to `users` table (migration needed).
2.  **Compare Fingerprints:** During login, compare and log/notify/challenge on new fingerprints.

### 5. Testing
(This section remains largely the same as the original plan - renumbered)

#### Backend Testing (PHPUnit)
*   Write integration tests for:
    *   Fortify TOTP: enabling, confirming, challenge with valid/invalid codes, recovery code usage.
    *   WebAuthn flows (once implemented): registration, authentication.
    *   Device fingerprinting logic.

#### Frontend Testing (Browser Compatibility)
*   Test across browsers:
    *   TOTP setup and login.
    *   WebAuthn registration and authentication (once implemented).
    *   Backup code login.
    *   FingerprintJS integration.

### 6. Compliance
(This section remains largely the same as the original plan - renumbered)

1.  **Set Up MFA Event Logging:**
    *   Configure log channel `mfa` in `[config/logging.php](mdc:config/logging.php)`.
    *   Log events for:
        *   TOTP enabled/disabled.
        *   TOTP challenge success/failure.
        *   Recovery code usage.
        *   WebAuthn registration/authentication (once implemented).
        *   New device detected via fingerprint.
2.  **Ensure Auditability:**
    *   Store logs in `mfa_logs` database table (migration needed).

### Notes

*   **Timeline (Adjusted):**
    *   Fortify TOTP 2FA (Backend & Frontend): ~3-4 days
    *   Backup Codes system (mostly covered by Fortify, frontend display): ~1 day
    *   WebAuthn implementation (Backend & Frontend): ~4-5 days (done after TOTP)
    *   Device Fingerprinting: ~1-2 days
    *   Testing (initial TOTP, then WebAuthn): ~1-2 days for each phase
    *   Compliance & Logging: ~1 day
    *   Total: Phased approach, initial TOTP setup could be faster.
*   **Dependencies:** `laravel/fortify`, `laragear/webauthn` (later), `@fingerprintjs/fingerprintjs`.
*   **Security:** As per original plan.
*   **Compliance (HIPAA):** As per original plan.
*   **User Communication:** Clear instructions for setting up authenticator apps, then later for WebAuthn.
*   **Frontend ArrayBuffer/Base64URL for WebAuthn:** Still relevant when WebAuthn is implemented.

This revised plan prioritizes getting a standard authenticator app based 2FA system live first.
